// by wuwbobo2021 <wuwbobo@outlook.com>
// Based on `i-slint-backend-android-activity` 1.8 source code

use jni::{
    objects::{JClass, JObject, JValue, JValueGen},
    JNIEnv,
};

pub struct JavaHelper(jni::objects::GlobalRef);

impl JavaHelper {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let ctx = ndk_context::android_context();
        // Safety: as documented in cargo-apk example to obtain the context object's JNI reference
        let context = unsafe { JObject::from_raw(ctx.context().cast()) }; // native activity
        let helper = create_object_from_dex(
            "JavaHelper",
            "(Landroid/app/Activity;)V",
            &[JValue::Object(&context)],
        )?;
        Ok(Self(helper))
    }

    pub fn test_get_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        self.with_jni_env(|env, helper| {
            let j_string = env
                .call_method(helper, "test_get_string", "()Ljava/lang/String;", &[])?
                .l()?;
            let string: String = env.get_string(&j_string.into())?.into();
            Ok(string)
        })
        .map_err(|e| e.into())
    }

    fn with_jni_env<R>(
        &self,
        f: impl FnOnce(&mut JNIEnv, &JObject<'static>) -> Result<R, jni::errors::Error>,
    ) -> Result<R, jni::errors::Error> {
        let ctx = ndk_context::android_context();
        // Safety: as documented in ndk-context to obtain a jni::JavaVM
        let vm = unsafe { jni::JavaVM::from_raw(ctx.vm().cast()) }?;
        let env = &mut vm.attach_current_thread()?;
        let helper = self.0.as_obj();
        f(env, helper)
    }
}

pub(crate) fn create_object_from_dex<S>(
    class_name: S,
    ctor_sig: S,
    ctor_args: &[JValue],
) -> Result<jni::objects::GlobalRef, jni::errors::Error>
where
    S: Into<jni::strings::JNIString> + AsRef<str>,
{
    // embeds the dex file generated by `build.rs`
    let dex_data = include_bytes!(concat!(env!("OUT_DIR"), "/classes.dex"));

    let ctx = ndk_context::android_context();
    // Safety: as documented in ndk-context to obtain a jni::JavaVM
    let vm = unsafe { jni::JavaVM::from_raw(ctx.vm().cast()) }?;
    let context = unsafe { JObject::from_raw(ctx.context().cast()) }; // native activity
    let env = &mut vm.attach_current_thread()?;

    let parent_dex_loader = env
        .call_method(&context, "getClassLoader", "()Ljava/lang/ClassLoader;", &[])?
        .l()?;

    let os_build_class = env.find_class("android/os/Build$VERSION")?;
    let sdk_ver = env.get_static_field(os_build_class, "SDK_INT", "I")?.i()?;

    // InMemoryDexClassLoader is introduced in API Level 26 (Android 8.0)
    let dex_loader = if sdk_ver >= 26 {
        // Safety: dex_data is 'static and the (InMemory)DexClassLoader will not mutate it it
        let dex_buffer = unsafe {
            env.new_direct_byte_buffer(dex_data.as_ptr() as *mut _, dex_data.len())
                .unwrap()
        };
        env.new_object(
            "dalvik/system/InMemoryDexClassLoader",
            "(Ljava/nio/ByteBuffer;Ljava/lang/ClassLoader;)V",
            &[
                JValue::Object(&dex_buffer),
                JValue::Object(&parent_dex_loader),
            ],
        )?
    } else {
        // writes the dex data into the application internal storage
        let dex_data_len = dex_data.len() as i32;
        let dex_byte_array = env.byte_array_from_slice(dex_data).unwrap();

        let dex_dir = env.new_string("dex")?;
        let dex_dir_path = env
            .call_method(
                &context,
                "getDir",
                "(Ljava/lang/String;I)Ljava/io/File;",
                &[JValue::Object(&dex_dir), JValueGen::Int(0)],
            )?
            .l()?;
        let dex_name = env.new_string(env!("CARGO_CRATE_NAME").to_string() + ".dex")?;
        let file_class = env.find_class("java/io/File")?;
        let dex_path = env.new_object(
            file_class,
            "(Ljava/io/File;Ljava/lang/String;)V",
            &[JValue::Object(&dex_dir_path), JValue::Object(&dex_name)],
        )?;
        let dex_path = env
            .call_method(dex_path, "getAbsolutePath", "()Ljava/lang/String;", &[])?
            .l()?;

        // prepares the folder for optimized dex generated by `DexClassLoader`
        let out_dex_dir = env.new_string("outdex")?;
        let out_dex_dir_path = env
            .call_method(
                &context,
                "getDir",
                "(Ljava/lang/String;I)Ljava/io/File;",
                &[JValue::Object(&out_dex_dir), JValueGen::Int(0)],
            )?
            .l()?;
        let out_dex_dir_path = env
            .call_method(
                &out_dex_dir_path,
                "getAbsolutePath",
                "()Ljava/lang/String;",
                &[],
            )?
            .l()?;

        // writes the dex data
        let output_stream_class = env.find_class("java/io/FileOutputStream")?;
        let write_stream = env.new_object(
            output_stream_class,
            "(Ljava/lang/String;)V",
            &[(&dex_path).into()],
        )?;
        env.call_method(
            &write_stream,
            "write",
            "([BII)V",
            &[
                JValue::Object(&dex_byte_array),
                JValueGen::Int(0),
                JValueGen::Int(dex_data_len),
            ],
        )?;
        env.call_method(&write_stream, "close", "()V", &[])?;

        // loads the dex file
        env.new_object(
            "dalvik/system/DexClassLoader",
            "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V",
            &[
                JValue::Object(&dex_path),
                JValue::Object(&out_dex_dir_path),
                JValue::Object(&JObject::null()),
                JValue::Object(&parent_dex_loader),
            ],
        )?
    };

    let class_name = env.new_string(class_name)?;
    let helper_class = env
        .call_method(
            dex_loader,
            "findClass",
            "(Ljava/lang/String;)Ljava/lang/Class;",
            &[JValue::Object(&class_name)],
        )?
        .l()?;
    let helper_class: JClass = helper_class.into();

    let helper_instance = env.new_object(helper_class, ctor_sig, ctor_args)?;
    env.new_global_ref(&helper_instance)
}
